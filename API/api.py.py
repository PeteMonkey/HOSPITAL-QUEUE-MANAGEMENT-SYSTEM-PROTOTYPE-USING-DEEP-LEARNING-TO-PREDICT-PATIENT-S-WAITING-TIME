# -*- coding: utf-8 -*-
"""Final Project Algorithm Part

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vxss7pADDHmKw6RlQieL2xiAU7j8Rl67

# Appointment & Queuing System


*   Reception-End
*   Manager-End

Note appiontment for the patient.

For the patients we seperate into 3 groups.

1.   Appointmented Patient
2.   Walk-in but want to select sepecific doctor.
3.   Walk-in

**Library**
---
"""
from flask import Flask, request, jsonify
import pyrebase
import urllib
import re

firebaseConfig = {'apiKey': "AIzaSyAbzQjX3Ci9ozaAdVqiO1419oI5SO_0blM",
  'authDomain': "project101-aa0a2.firebaseapp.com",
  'databaseURL': "https://project101-aa0a2-default-rtdb.asia-southeast1.firebasedatabase.app",
  'projectId': "project101-aa0a2",
  'storageBucket': "project101-aa0a2.appspot.com",
  'messagingSenderId': "964381748399",
  'appId': "1:964381748399:web:de9d4c8d434a62a0bab85a",
  'measurementId': "G-YLCSPGSD2M"}


firebase = pyrebase.initialize_app(firebaseConfig)
db = firebase.database()

firebaseConfig = {'apiKey': "AIzaSyAbzQjX3Ci9ozaAdVqiO1419oI5SO_0blM",
  'authDomain': "project101-aa0a2.firebaseapp.com",
  'databaseURL': "https://project101-aa0a2-default-rtdb.asia-southeast1.firebasedatabase.app",
  'projectId': "project101-aa0a2",
  'storageBucket': "project101-aa0a2.appspot.com",
  'messagingSenderId': "964381748399",
  'appId': "1:964381748399:web:a9de64abb38f1602bab85a",
  'measurementId': "G-P597F7S9RV"}

firebase = pyrebase.initialize_app(firebaseConfig)
storage = firebase.storage()

storage.child('project101-aa0a2-firebase-adminsdk-dlmk0-fa5b8fcaf7.json').download('project101-aa0a2-firebase-adminsdk-dlmk0-fa5b8fcaf7.json', filename=f"project101-aa0a2-firebase-adminsdk-dlmk0-fa5b8fcaf7.json")
from google.cloud import storage as gcs_storage

gcs_client = gcs_storage.Client.from_service_account_json('project101-aa0a2-firebase-adminsdk-dlmk0-fa5b8fcaf7.json')
bucket = gcs_client.get_bucket('project101-aa0a2.appspot.com')

#adding
import tensorflow as tf
from joblib import dump, load
import pandas as pd
import numpy as np 
import os
import pickle

from prettytable import PrettyTable
from datetime import date
from datetime import timedelta
import datetime
import time
import collections
from collections import deque

from urllib.parse import unquote

app = Flask(__name__)

"""**Basic System**
---



"""

class Patient:
    patient_data = []
    patient_dict = {}
    
    def __init__(self,id,name,birthday,sex):
        self.id = id
        self.name = name
        self.birthday = birthday
        self.sex = sex
    
    def set_patient_data(self,patient_id, name, birthday, sex):
        data = {"name": name, "birthday": birthday, "sex": sex}
        db.child("Patient").child("MED").child(patient_id).set(data)
    
    def update_patient_data(self,patient_id, name=None, birthday=None, sex=None):
        data = {}
        if name is not None:
            data["name"] = name
        if birthday is not None:
            data["birthday"] = birthday
        if sex is not None:
            data["sex"] = sex
        if data:
            db.child("Patient").child("MED").child(patient_id).update(data)

    def update_multiple_locations(self,patient_data):
        for data in patient_data:
            db.child(data['location']).update(data['data'])

    def get_patient_data(self,patient_id):
        patient_info = db.child("Patient").child("MED").child(patient_id).get()
        if patient_info.val() is None:
            print("No data found for patient", patient_id)
            return {}
        else:
            info_dict = {}
            for info in patient_info.each():
                info_dict[info.key()] = info.val()
            return info_dict

class Doctor:
    doctor_data = []
    doctor_dict = {}
   
    def __init__(self,name,room_no):
        self.name = name
        self.room_no = room_no

    def show_doctor_data(self):
        print("The Doctor Data")
        print("While the data show the [Doctor's Name, Doctor Room Number]")
        for i in range(len(self.doctor_data)):
            print(f"{i+1} {self.doctor_data[i]}")

    def add_doctor(self,name,room_no):
        add_doctor = Doctor(name,room_no)
        Doctor.doctor_data.append([name,room_no])
        Doctor.doctor_dict[room_no] = name
        #________________________________________________________
        D_data = {"Room": room_no,"status" : 'ARRIVED'}
        db.child("Doctor").child("อายุรกรรม").child(name).set(D_data)
    
    def search_doctor(self,room_no):
        if room_no in Doctor.doctor_dict:
            print(f"Doctor room {room_no}: {Doctor.doctor_dict[room_no]}")
        else:
            print("Don't have data")

"""**Create a Patinet and Doctor**

---




"""
# Create a new doctor
d1 = Doctor("Dr_Jim",1)
d1.add_doctor("Dr_Jim",1)
d2 = Doctor("Dr_Joo",2)
d2.add_doctor("Dr_Joo",2)


"""**Time prossing**
---


"""

def load_scaler(section,room):
  remote_path = f"memory/scaler/{section}/{room}_{section}_scaler.pkl"
  # path to the local file where the downloaded file will be saved
  local_path = f"memory/scaler/{section}/{room}_{section}_scaler.pkl"
  # download the file from Firebase Storage
  storage.child(remote_path).download(local_path, filename=f"{room}_{section}_scaler.pkl")
  # load the scaler object from the local file
  with open(f"/content/{room}_{section}_scaler.pkl", "rb") as f:
        scaler = pickle.load(f)
  return scaler

def load_3_of_model(section, room,fold):
    remote_path = f"memory/models/{section}/{room}/{room}_{section}_Flod{fold+1}_lstm_model.h5"
    # path to the local file where the downloaded file will be saved
    local_path = f"memory/models/{section}/{room}/{room}_{section}_Flod{fold+1}_lstm_model.h5"
    # download the file from Firebase Storage
    storage.child(remote_path).download(local_path, filename=f"{room}_{section}_Flod{fold+1}_lstm_model.h5")
    # load the scaler object from the local file
    model = tf.keras.models.load_model(f"/content/{room}_{section}_Flod{fold+1}_lstm_model.h5")
    return model

def prediction(day,hour,section,room):
  df_prediction = pd.DataFrame({'day': [day], 'hour': [hour]})
  df_prediction.loc[df_prediction['day'] == 'Monday',     ['day_code1', 'day_code2', 'day_code3', 'day_code4']] = [0, 0, 0, 1]
  df_prediction.loc[df_prediction['day'] == 'Tuesday',    ['day_code1', 'day_code2', 'day_code3', 'day_code4']] = [0, 0, 1, 0]
  df_prediction.loc[df_prediction['day'] == 'Wednesday',  ['day_code1', 'day_code2', 'day_code3', 'day_code4']] = [0, 0, 1, 1]
  df_prediction.loc[df_prediction['day'] == 'Thursday',   ['day_code1', 'day_code2', 'day_code3', 'day_code4']] = [0, 1, 0, 0]
  df_prediction.loc[df_prediction['day'] == 'Friday',     ['day_code1', 'day_code2', 'day_code3', 'day_code4']] = [0, 1, 0, 1]
  df_prediction.loc[df_prediction['day'] == 'Saturday',   ['day_code1', 'day_code2', 'day_code3', 'day_code4']] = [0, 1, 1, 0]
  df_prediction.loc[df_prediction['day'] == 'Sunday',     ['day_code1', 'day_code2', 'day_code3', 'day_code4']] = [0, 1, 1, 1]
  df_prediction.loc[df_prediction['hour'] == '08-09', ['hour_code1', 'hour_code2', 'hour_code3', 'hour_code4']] = [0, 0, 0, 1]
  df_prediction.loc[df_prediction['hour'] == '09-10', ['hour_code1', 'hour_code2', 'hour_code3', 'hour_code4']] = [0, 0, 1, 0]
  df_prediction.loc[df_prediction['hour'] == '10-11', ['hour_code1', 'hour_code2', 'hour_code3', 'hour_code4']] = [0, 0, 1, 1]
  df_prediction.loc[df_prediction['hour'] == '11-12', ['hour_code1', 'hour_code2', 'hour_code3', 'hour_code4']] = [0, 1, 0, 0]
  df_prediction.loc[df_prediction['hour'] == '12-13', ['hour_code1', 'hour_code2', 'hour_code3', 'hour_code4']] = [0, 1, 0, 1]
  df_prediction.loc[df_prediction['hour'] == '13-14', ['hour_code1', 'hour_code2', 'hour_code3', 'hour_code4']] = [0, 1, 1, 0]
  df_prediction.loc[df_prediction['hour'] == '14-15', ['hour_code1', 'hour_code2', 'hour_code3', 'hour_code4']] = [0, 1, 1, 1]
  df_prediction.loc[df_prediction['hour'] == '15-16', ['hour_code1', 'hour_code2', 'hour_code3', 'hour_code4']] = [1, 0, 0, 0]
  df_prediction.loc[df_prediction['hour'] == '16-17', ['hour_code1', 'hour_code2', 'hour_code3', 'hour_code4']] = [1, 0, 0, 1]
  df_prediction[['day_code1', 'day_code2', 'day_code3', 'day_code4','hour_code1', 'hour_code2', 'hour_code3', 'hour_code4']] = df_prediction[['day_code1', 'day_code2', 'day_code3', 'day_code4','hour_code1', 'hour_code2', 'hour_code3', 'hour_code4']].astype(int)
  X1 = df_prediction[['day_code1', 'day_code2', 'day_code3', 'day_code4']] = df_prediction[['day_code1', 'day_code2', 'day_code3', 'day_code4']].values
  X2 = df_prediction[['hour_code1', 'hour_code2', 'hour_code3', 'hour_code4']] = df_prediction[['hour_code1', 'hour_code2', 'hour_code3', 'hour_code4']].values
  X1_reshape = np.reshape(X1, (X1.shape[0], X1.shape[1], 1))
  X2_reshape = np.reshape(X2, (X2.shape[0], X2.shape[1], 1))
  X = np.concatenate((X1_reshape, X2_reshape), axis=2)
  scaler = load_scaler(section,room)
  predictions_sum = np.zeros((1,1))
  for fold in range(3):
    model = load_3_of_model(section, room,fold)
    exec(f"predictions_{fold+1} = model.predict(np.array(X))")
    exec(f"predictions_sum += predictions_{fold+1}")
    os.remove(f"{room}_{section}_Flod{fold+1}_lstm_model.h5")
  prediction = scaler.inverse_transform(predictions_sum/3)
  os.remove(f"{room}_{section}_scaler.pkl")
  #X_original = scaler.load_3_of_model(section, room,X)
  #minutes = X_original / 60
  #hours = minutes / 60
  #f'{int(hours)} hr {int(minutes % 60)} min'
  return prediction

"""**Time Recorder**
---

"""

def exists_file(doctor):
  num_rows = 0
  file_path = f'Time_recorder/{doctor}/time_all/{doctor}_time_all.csv'
  # Check if the file exists in the bucket
  blob = bucket.blob(file_path)
  if blob.exists():
      print('File exists')
      remote_path = f"Time_recorder/{doctor}/time_all/{doctor}_time_all.csv"
      # path to the local file where the downloaded file will be saved
      local_path = f"Time_recorder/{doctor}/time_all/{doctor}_time_only.csv"
      # download the file from Firebase Storage
      storage.child(remote_path).download(local_path, filename=f"{doctor}_time_all.csv")
      df = pd.read_csv(f'/content/{doctor}_time_all.csv')
      num_rows = df.shape[0]
      os.remove(f"{doctor}_time_all.csv")
  else:
        print('File does not exist')
        df = pd.DataFrame(columns=['Start_time','Stop_time','Name','Patient_ID','Birthday','Sex'])
  return df,num_rows
      
def time_recorder(doctor,patient_id):
  df,num_rows = exists_file(doctor)
  start = datetime.datetime.now()
  data = Patient.get_patient_data(Patient,patient_id)
  if num_rows == 0:
    df.at[num_rows,'Start_time'] = start
  else :
    df.at[num_rows,'Start_time'] = start
    df.at[num_rows-1, 'Stop_time'] = start
  df.at[num_rows,'Patient_ID'] = patient_id
  df.at[num_rows,'Name'] = data['name']
  df.at[num_rows,'Birthday'] = data['birthday']
  df.at[num_rows,'Sex'] = data['sex']
  # save the updated dataframe to CSV file
  df.to_csv(f"{doctor}_time_all.csv", index=False)
  # Upload file to Firebase storage
  storage.child(f'Time_recorder/{doctor}/time_all/{doctor}_time_all.csv').put(f'{doctor}_time_all.csv')
  os.remove(f"{doctor}_time_all.csv")
  return

def exists_doctor(doctor):
  num_rows = 0
  file_path = f'Time_recorder/{doctor}/time_only/{doctor}_time_only.csv'
  # Check if the file exists in the bucket
  blob = bucket.blob(file_path)
  if blob.exists():
      print('File exists')
      remote_path = f"Time_recorder/{doctor}/time_only/{doctor}_time_only.csv"
      # path to the local file where the downloaded file will be saved
      local_path = f"Time_recorder/{doctor}/time_only/{doctor}_time_only.csv"
      # download the file from Firebase Storage
      storage.child(remote_path).download(local_path, filename=f"{doctor}_time_only.csv")
      df = pd.read_csv(f'/content/{doctor}_time_only.csv')
      num_rows = df.shape[0]
      os.remove(f"{doctor}_time_only.csv")
  else:
      print('File does not exist')
      df = pd.DataFrame(columns=['Start_time','Stop_time'])
  return df,num_rows

def start_recorder(doctor,patient_id):
    df,num_rows = exists_doctor(doctor)
    start = datetime.datetime.now()
    data = Patient.get_patient_data(Patient,patient_id)
    df.at[num_rows,'Start_time'] = start
    df.at[num_rows,'Patient_ID'] = patient_id
    df.at[num_rows,'Name'] = data['name']
    df.at[num_rows,'Birthday'] = data['birthday']
    df.at[num_rows,'Sex'] = data['sex']

    # save the updated dataframe to CSV file
    df.to_csv(f"{doctor}_time_only.csv", index=False)
    
    # upload the CSV file to Firebase Storage
    remote_path = f"Time_recorder/{doctor}/time_only/{doctor}_time_only.csv"
    storage.child(remote_path).put(f"{doctor}_time_only.csv")
    os.remove(f"{doctor}_time_only.csv")
    return

def stop_recorder(doctor):
    df,num_rows = exists_doctor(doctor)
    stop = datetime.datetime.now()
    df.at[num_rows-1,'Stop_time'] = stop

    # save the updated dataframe to CSV file
    df.to_csv(f"{doctor}_time_only.csv", index=False)
    
    # upload the CSV file to Firebase Storage
    remote_path = f"Time_recorder/{doctor}/time_only/{doctor}_time_only.csv"
    storage.child(remote_path).put(f"{doctor}_time_only.csv")
    os.remove(f"{doctor}_time_only.csv")
    return

"""**Status**
---
"""

def status_waiting(doctor):
  D_data = {"status" : 'WAITING'}
  db.child("Doctor").child("อายุรกรรม").child(doctor).update(D_data)
  return
def status_ready(doctor):
  D_data = {"status" : 'READY'}
  db.child("Doctor").child("อายุรกรรม").child(doctor).update(D_data)
  return
def status_busy(doctor):
  D_data = {"status" : 'BUSY'}
  db.child("Doctor").child("อายุรกรรม").child(doctor).update(D_data)
  return 
def status_break(doctor):
  D_data = {"status" : 'BREAK'}
  db.child("Doctor").child("อายุรกรรม").child(doctor).update(D_data)
  return
def status_arrived(doctor):
  D_data = {"status" : 'ARRIVED'}
  db.child("Doctor").child("อายุรกรรม").child(doctor).update(D_data)
  return
def status_offline(doctor):
  D_data = {"status" : 'OFFLINE'}
  db.child("Doctor").child("อายุรกรรม").child(doctor).update(D_data)
  return

def status_display(doctor):
  return
@app.route('/start_button/<string:doctor>', methods=['GET'])
def start_button(doctor):
  now = datetime.datetime.now()
  year, month, day = now.year, now.month, now.day
  patient_id = (db.child("Doctor_Push_Start").child(f"{year}/{month}/{day}").child(doctor).get()).val()
  start_recorder(doctor,patient_id)
  status_busy(doctor)
  db.child("Doctor_Push_Start").child(f"{year}/{month}/{day}").child(doctor).remove()
  return jsonify("Time recording has started")
@app.route('/finish_button/<string:doctor>', methods=['GET'])
def finish_button(doctor):
  stop_recorder(doctor)
  status_waiting(doctor)
  return jsonify("Time recording has stopped")
@app.route('/ready_button/<string:doctor>', methods=['GET'])
def ready_button(doctor):
  status_ready(doctor)
  return jsonify("Status: Ready")
@app.route('/absent_button/<string:doctor>', methods=['GET'])
def absent_button(doctor):
  status_waiting(doctor)
  return jsonify("Status: Waiting. Patient Absent")
@app.route('/break_button/<string:doctor>', methods=['GET'])
def break_button(doctor):
  status_break(doctor)
  return jsonify("Status: Break")
@app.route('/back_button/<string:doctor>', methods=['GET'])
def back_button(doctor):
  status_waiting(doctor)
  return jsonify("Status: Waiting")
@app.route('/get_start_button/<string:doctor>', methods=['GET'])
def get_start_button(doctor):
  status_waiting(doctor)
  return jsonify("Status: Waiting")
@app.route('/back_icon_button/<string:doctor>', methods=['GET'])
def back_icon_button(doctor):
  status_arrived(doctor)
  return jsonify("Status: Arrived")
@app.route('/enter_button/<string:doctor>', methods=['GET'])
def enter_button(doctor):
  status_arrived(doctor)
  return jsonify("Status: Arrived")
@app.route('/exit_button/<string:doctor>', methods=['GET'])
def exit_button(doctor):
  status_offline(doctor)
  return jsonify("Status: Offline")


"""**Queuing  System**
---

**Ticket System**


---
"""

def generate_items():
    alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    char1 = "A"
    i = 1
    while True:
        yield f"{char1}{str(i).zfill(2)}"
        i += 1
        if i == 100:
            char1_index = alphabet.index(char1)
            char1_index += 1
            if char1_index == len(alphabet):
                char1_index = 0
                # reset values to A01 at the start of each day
                if datetime.datetime.now().hour == 0:
                    char1 = "A"
                    i = 1
                else:
                    char1 = alphabet[char1_index]
                    i = 0

"""**Queuing System**

*   add: Add queue to
*   List item


---

"""

class Queue:
    def __init__(self):
        self.queue = deque()
        self.tickets = generate_items()

    def add(self, appointment):
        appointment.ticket = next(self.tickets)

        # Adding waiting time prediction
        day = "Tuesday"
        hour = "10-11"
        section = "อายุรกรรม"
        room = "1"
        appointment.waiting_time = 800  # prediction(day, hour, section, room)

        self.queue.appendleft(appointment)

        # Convert the deque to a list, sort it, and then convert it back to a deque
        sorted_list = sorted(list(self.queue), key=lambda x: x.waiting_time)
        self.queue = collections.deque(sorted_list)

        # Get the current date
        now = datetime.datetime.now()
        year = now.year
        month = now.month
        day = now.day

        # Iterate through the queue and update Waiting_Time and Patient_Ahead for each patient
        total_waiting_time = 0
        for index, appointment in enumerate(self.queue):
            patient_id = appointment.patient_id
            patients_ahead = index

            # Update the total_waiting_time
            total_waiting_time += appointment.waiting_time

            waiting_time_hours = int(total_waiting_time / (60 * 60))
            waiting_time_minutes = int((total_waiting_time / 60) % 60)

            # Find Doctor's room in dictenary
            doctor_room_no = None
            for room_no, name in Doctor.doctor_dict.items():
                if name == appointment.doctor:
                    doctor_room_no = room_no
                    break

            # Prepare the Queue Ticket
            queue_ticket = {
                "Patient_ID": appointment.patient_id,
                "Ticket": appointment.ticket,
                "Waiting_Time": f"{waiting_time_hours}h {waiting_time_minutes}m",
                "Patient Ahead": patients_ahead,
                "Dr_Name": appointment.doctor,
                "Dr_Room": doctor_room_no,
            }

            # Store the Queue Ticket in the Firebase Realtime Database
            db.child("Patient_Queue").child(f"{year}/{month}/{day}/{patient_id}").update(queue_ticket)
            
            queue.cal_table(appointment.doctor)

    @app.route('/remove/<string:doctor>', methods=['GET'])
    def remove(doctor):
        appointments = [appointment for appointment in queue.queue if appointment.doctor == doctor]
        if not appointments:
            return jsonify(f"No appointments found for doctor {doctor}.")
        else:
            appointment = appointments[-1]
            queue.queue.remove(appointment)
            
            queue.cal_table(doctor)

            # Remove patient data from Firebase Realtime Database
            now = datetime.datetime.now()
            year, month, day = now.year, now.month, now.day
            patient_id = appointment.patient_id
            db.child("Patient_Queue").child(f"{year}/{month}/{day}/{patient_id}").remove()
            #________________________________________________________________
            time_recorder(doctor,appointment.patient_id)
            return jsonify(f"Removed appointment for patient with id {appointment.patient_id} for doctor {doctor}.")

    @app.route('/walkin/<int:patient_id>/<string:doctor>', methods=['GET'])
    def walkin(patient_id, doctor):
        current_datetime = datetime.datetime.now()
        appointment = Appointment(current_datetime, current_datetime, patient_id, doctor)
        queue.add(appointment)
        return jsonify(f"Walk-in patient with id {patient_id} has been added to the queue for doctor {doctor} Queue number: {appointment.ticket}.")

    def cal_table(self, doctor):
        # Get the doctor's name and room number
        doctor_room_no = None
        doctor_name = None
        for room_no, name in Doctor.doctor_dict.items():
            if name == doctor:
                doctor_room_no = room_no
                doctor_name = name.replace('_', '.')  # Replace underscore with dot
                break

        if doctor_room_no is None:
            print(f"No doctor found with the name {doctor}.")
            return

        if not self.queue:
            print(f"No confirmed appointments found.")
        else:
            x = PrettyTable()
            x.field_names = ["Order", "Patient", "Ticket", "Hours", "Minutes", "Doctor", "Room No", "Patients Ahead"]
            appointments = [appointment for appointment in self.queue if appointment.doctor == doctor]
            if not appointments:
                print(f"No confirmed appointments found for doctor {doctor_name} in room {doctor_room_no}.")
            else:
                appointments = list(reversed(appointments))
                for index, appointment in enumerate(appointments, 1):
                    position = self.patient_ticket_position(appointment.patient_id)["position"]
                    if position is not None:
                        patients_ahead = index - 1
                    else:
                        position = "N/A"
                        patients_ahead = "N/A"

                    # Update Waiting_Time and Patient Ahead in Firebase Realtime Database
                    patient_id = appointment.patient_id
                    now = datetime.datetime.now()
                    year, month, day = now.year, now.month, now.day
                    waiting_time_hours = int(appointment.waiting_time * index / (60 * 60))
                    waiting_time_minutes = int((appointment.waiting_time * index / 60) % 60)
                    db.child("Patient_Queue").child(f"{year}/{month}/{day}/{patient_id}").update({
                        "Waiting_Time": f"{waiting_time_hours}h {waiting_time_minutes}m",
                        "Patient Ahead": patients_ahead
                    })
                    x.add_row([index, patient_id, appointment.ticket, waiting_time_hours, waiting_time_minutes, doctor_name, doctor_room_no, patients_ahead])
              
    def display_table(self, doctor):
        # Get the doctor's name and room number
        doctor_room_no = None
        doctor_name = None
        for room_no, name in Doctor.doctor_dict.items():
            if name == doctor:
                doctor_room_no = room_no
                doctor_name = name.replace('_', '.')  # Replace underscore with dot
                break

        if doctor_room_no is None:
            print(f"No doctor found with the name {doctor}.")
            return

        if not self.queue:
            print(f"No confirmed appointments found.")
        else:
            x = PrettyTable()
            x.field_names = ["Order", "Patient", "Ticket", "Hours", "Minutes", "Doctor", "Room No", "Patients Ahead"]
            appointments = [appointment for appointment in self.queue if appointment.doctor == doctor]
            if not appointments:
                print(f"No confirmed appointments found for doctor {doctor_name} in room {doctor_room_no}.")
            else:
                appointments = list(reversed(appointments))
                for index, appointment in enumerate(appointments, 1):
                    position = self.patient_ticket_position(appointment.patient_id)["position"]
                    if position is not None:
                        patients_ahead = index - 1
                    else:
                        position = "N/A"
                        patients_ahead = "N/A"

                    # Update Waiting_Time and Patient Ahead in Firebase Realtime Database
                    patient_id = appointment.patient_id
                    now = datetime.datetime.now()
                    year, month, day = now.year, now.month, now.day
                    waiting_time_hours = int(appointment.waiting_time * index / (60 * 60))
                    waiting_time_minutes = int((appointment.waiting_time * index / 60) % 60)
                    db.child("Patient_Queue").child(f"{year}/{month}/{day}/{patient_id}").update({
                        "Waiting_Time": f"{waiting_time_hours}h {waiting_time_minutes}m",
                        "Patient Ahead": patients_ahead
                    })
                    x.add_row([index, patient_id, appointment.ticket, waiting_time_hours, waiting_time_minutes, doctor_name, doctor_room_no, patients_ahead])
                print(f"Queuing Table For {doctor_name}")
                print(x)

    def patient_ticket_position(self, patient_id):
        queue_list = list(self.queue)
        queue_list.reverse()
        queue_len = len(queue_list)
        for i in range(queue_len):
            if queue_list[i].patient_id == patient_id:
                return {"position": queue_len - i, "queue_len": queue_len - 1}
        return {"position": None, "queue_len": queue_len - 1}
queue = Queue()

"""**Show Patient Data in a Ticket**

---

"""

@app.route('/get_patient_data_button/<int:patient_id>', methods=['GET'])
def get_patient_data(patient_id):
    now = datetime.datetime.now()
    year = now.year
    month = now.month
    day = now.day

    patient_data = db.child("Patient_Queue").child(f"{year}/{month}/{day}/{patient_id}").get()

    if patient_data.val() is None:
        return None  # No data found for the given patient_id

    return jsonify(patient_id,patient_data.val())

def get_patient_data_button(patient_id):
    while True:
        patient_data = get_patient_data(patient_id)
        if patient_data is not None:
            print(patient_data)
        else:
            print("Your Queue!!")
            break
        time.sleep(2)

"""**Appointment System**
---


"""

class Appointment:
    def __init__(self, start_time, end_time, patient_id, doctor, ticket=None, waiting_time = None):
        self.start_time = start_time
        self.end_time = end_time
        self.patient_id = patient_id
        self.doctor = doctor
        self.ticket = ticket
        self.waiting_time = waiting_time

class Hospital:
    def __init__(self, name, capacity):
        self.name = name
        self.capacity = capacity
        self.appointments = []


    def make_appointment(self, start_time, end_time, patient_id, doctor):
        # Check if the start time is in the past
        if start_time < datetime.datetime.now():
            return jsonify("Sorry, appointments cannot be made in the past.")

        # Check if there are less than 6 appointments in the given hour
        appointments_in_hour = [a for a in self.appointments if a.start_time.hour == start_time.hour]
        if len(appointments_in_hour) >= 50:
            return jsonify(f"Sorry, there are no available appointments at {start_time}.")

       # Check if the time slot is available for the doctor
        if self.check_doctor_availability(start_time, end_time, doctor):
            return jsonify(f"Sorry, Doctor {doctor} already has an appointment during {start_time.strftime('%H:%M')}-{end_time.strftime('%H:%M')}")

        # If there are available appointments, create a new one
        appointment = Appointment(start_time, end_time, patient_id, doctor)
        self.appointments.append(appointment)
        

        # Save appointment to Firebase Realtime Database
        doctor = re.sub('[^0-9a-zA-Z]+', '_', doctor)
        year, month, day = start_time.year, start_time.strftime("%b"), start_time.day
        doctor_node = f"{doctor}/{year}/{month}/{day}/{patient_id}"
        appointment_dict = {
            "start_time": start_time.isoformat(),
            "end_time": end_time.isoformat(),
            "status" : "not_confirm"
        }
        db.child("Appointment").child(doctor_node).set(appointment_dict)
        
        # Store patient appointment information in Firebase Realtime Database
        patient_node = f"Patient_Appointment/{patient_id}/{doctor}/{year}/{month}/{day}"
        patient_appointment_dict = {
            "start_time": start_time.isoformat(),
            "end_time": end_time.isoformat(),
            "status": "not_confirm"
        }
        db.child(patient_node).set(patient_appointment_dict)
        return jsonify(f"Patient: {patient_id} has been appointed to doctor {doctor} during {start_time.strftime('%H:%M')}-{end_time.strftime('%H:%M')}")

    def check_doctor_availability(self, start_time, end_time, doctor):
        for appointment in self.appointments:
            if appointment.doctor == doctor and (appointment.start_time <= start_time < appointment.end_time or appointment.start_time < end_time <= appointment.end_time):
                return True
        return False

    def display_appointments(self, doctor):
        # Display all the appointments for a given doctor in tabular format
        appointments = [appointment for appointment in self.appointments if appointment.doctor == doctor]
        if not appointments:
            print(f"No appointments found for Doctor {doctor}.")
        else:
            x = PrettyTable()
            x.field_names = ["Date", "Start Time", "End Time", "Patient_ID", "Status"]
            for appointment in appointments:
                year, month, day = appointment.start_time.year, appointment.start_time.strftime("%b"), appointment.start_time.day
                patient_id = appointment.patient_id
                doctor_node = f"{re.sub('[^0-9a-zA-Z]+', '_', doctor)}/{year}/{month}/{day}/{patient_id}"
                status = db.child("Appointment").child(doctor_node).child("status").get().val()

                x.add_row([appointment.start_time.strftime("%d %b %Y"), appointment.start_time.strftime("%H:%M"), appointment.end_time.strftime("%H:%M"), appointment.patient_id, status])
            print(f"Appointments for Doctor {doctor}:")
            print(x)

    
    def confirm_appointment(self, patient_id, doctor, queue):
        # Get the current date and time
        now = datetime.datetime.now()

        # Find all appointments for the given patient and doctor
        doctor = re.sub('[^0-9a-zA-Z]+', '_', doctor)  # Replace any invalid characters with an underscore
        year, month = now.year, now.strftime("%b")
        patient_node = f"{patient_id}/{doctor}/{year}/{month}"
        appointments = db.child("Patient_Appointment").child(patient_node).get().val()
        if not appointments:
            raise Exception("No appointments found for the given patient and doctor.")

        # Filter appointments for today only
        patient_appointments = []
        already_confirmed = False
        day_data = appointments.get(str(now.day), {})
        if isinstance(day_data, dict):
            appointment_data = day_data
            start_time = datetime.datetime.fromisoformat(appointment_data['start_time'])
            end_time = datetime.datetime.fromisoformat(appointment_data['end_time'])
            status = appointment_data['status']
            waiting_time = (start_time - now).total_seconds()
            appointment = Appointment(start_time, end_time, patient_id, doctor, waiting_time=waiting_time)

            if status == "confirm":
                already_confirmed = True

            patient_appointments.append(appointment)

        if already_confirmed:
            raise Exception("This appointment has already been confirmed.")

        if not patient_appointments:
            raise Exception("No appointments found for the given patient and doctor today.")

        # If there is more than one appointment, ask the patient to choose one
        if len(patient_appointments) > 1:
            print("Multiple appointments found. Please choose one to confirm:")
            for i, appointment in enumerate(patient_appointments, 1):
                print(f"{i}. {appointment.start_time.strftime('%H:%M')} - {appointment.end_time.strftime('%H:%M')}")
            choice = int(input("Enter the appointment number to confirm: "))
            appointment_to_confirm = patient_appointments[choice - 1]
        else:
            appointment_to_confirm = patient_appointments[0]

        # Check if the appointment can be confirmed (within 30 minutes before the appointment time)
        if now <= appointment_to_confirm.start_time - datetime.timedelta(minutes=30):
            # Update the appointment status in the Firebase Realtime Database
            year, month, day = appointment_to_confirm.start_time.year, appointment_to_confirm.start_time.strftime("%b"), appointment_to_confirm.start_time.day
            doctor_node = f"{re.sub('[^0-9a-zA-Z]+', '_', doctor)}/{year}/{month}/{day}/{patient_id}"
            db.child("Appointment").child(doctor_node).update({"status": "confirm"})
            db.child("Patient_Appointment").child(patient_node).child(f"{year}/{month}/{day}").update({"status": "confirm"})
            print(f"Appointment for patient {patient_id} with Doctor {doctor} at {appointment_to_confirm.start_time.strftime('%H:%M')} has been confirmed.")
        else:
            print("The appointment cannot be confirmed. You must confirm at least 30 minutes before the appointment time.")

        # Select the appointment to confirm
        confirmed_appointment = None
        if len(patient_appointments) > 1:
            print("Please choose the appointment you want to confirm:")
            for i, appointment in enumerate(patient_appointments, 1):
                print(f"{i}. {appointment.start_time.strftime('%H:%M')} - {appointment.end_time.strftime('%H:%M')}")
            selected_index = int(input("Enter the number of the appointment: ")) - 1
            confirmed_appointment = patient_appointments[selected_index]
        elif patient_appointments:
            confirmed_appointment = patient_appointments[0]

        # After confirming the appointment, update the status in the Firebase Realtime Database
        if confirmed_appointment:

            # Add the confirmed appointment to the queue
            queue.add(confirmed_appointment)
            
            # Create the appointment node path
            year, month, day = confirmed_appointment.start_time.year, confirmed_appointment.start_time.strftime("%b"), confirmed_appointment.start_time.day
            doctor_node = f"{re.sub('[^0-9a-zA-Z]+', '_', doctor)}/{year}/{month}/{day}/{patient_id}"
    
            # Update the status in the doctor's appointment node
            db.child("Appointment").child(doctor_node).update({"status": "confirm"})

            # Update the status in the patient's appointment node
            patient_node = f"Patient_Appointment/{patient_id}/{re.sub('[^0-9a-zA-Z]+', '_', doctor)}/{year}/{month}/{day}"
            db.child(patient_node).update({"status": "confirm"})

hospital = Hospital("Klong Luang's Hospital", 200)


# Make Appointment From Flutter
@app.route('/get_datetime_from_url/<string:url_datetime_start>/<string:url_datetime_end>/<int:patient_id>/<string:doctor>', methods=['GET'])
def get_datetime_from_url(url_datetime_start,url_datetime_end, patient_id, doctor):
    decoded_datetime_start = unquote(url_datetime_start)
    datetime_object_start = datetime.datetime.strptime(decoded_datetime_start, '%Y-%m-%d %H:%M')
    decoded_datetime_end = unquote(url_datetime_end)
    datetime_object_end = datetime.datetime.strptime(decoded_datetime_end, '%Y-%m-%d %H:%M')    
    hospital.make_appointment(datetime_object_start, datetime_object_end, patient_id, doctor)

    
    # return datetime_object_start,datetime_object_end

@app.route('/linkto_confirm_appointment/<int:patient_id>/<string:doctor>')
def linkto_confirm_appointment(patient_id,doctor):
  try:
      hospital.confirm_appointment(patient_id,doctor, queue)
  except Exception as ex:
      print(ex)

class AppointmentManager:
    def __init__(self):
        self.appointments = []
        self.db = firebase.database()

    def get_appointments(self, doctor, year, month, day=None):
        # Create the doctor node path in the Firebase Realtime Database
        doctor = re.sub('[^0-9a-zA-Z]+', '_', doctor)
        doctor_node = f"{year}/{month}"
        if day:
            doctor_node += f"/{day}"

        # Retrieve all appointments for the given doctor from the Firebase Realtime Database
        appointments = self.db.child("Appointment").child(doctor).child(doctor_node).get().val()

        # Return the appointments as a list of dictionaries, or an empty list if there are no appointments
        if appointments:
            # Create a list to hold the appointments
            appointment_list = []

            # Loop through the appointments and add the patient_id to each one
            for appointment_key, appointment_data in appointments.items():
                appointment = appointment_data
                appointment['patient_id'] = appointment_key.split('/')[-1]
                appointment_list.append(appointment)

            # Return the list of appointments
            return appointment_list
        else:
            print(f"No appointments found on {day}/{month}/{year} for Dr. {doctor}.")
            return []

manager = AppointmentManager()
manager.get_appointments("Dr.Jim", 2023, "Apr",10)

if __name__ == "__main__":
    app.run()